From: Urs =?ISO-8859-1?Q?Jan=DFen?= <urs@tin.org>
Subject: [PATCH] tin 1.9.2 and Typhoon v2.1.1.363
Date: Thu, 08 Feb 2007 13:36:35 +0100
To: tin-dev@tin.org

Typhoon v2.1.1.363 closes the connection after receiving an unknown
command, as with tin 1.9.2 the code uses the new CAPABILITIES cmd
(RFC 3977) but Typhoon doesn't support it yet (AFAIK there is
currently no server software which does) and so we end up in an
endless reconnection loop (well tin dumps core after a while, I
didn't check why and where - i just fixed the cause of the loop).

btw. anyone willing to look at the cancel/'-' bug reported by mow
last week?

--- tin/src/nntplib.c	2007-01-09 13:48:46.000000000 +0100
+++ tin/src/nntplib.c	2007-02-08 13:26:37.746762262 +0100
@@ -42,10 +42,8 @@
 	/* Copy of last NNTP command sent, so we can retry it if needed */
 	static char last_put[NNTP_STRLEN];
 	static constext *xover_cmds = "XOVER";
-#	if 0 /* currently not used */
 	static constext *xhdr_cmds = "XHDR";
-#	endif /* 0 */
-	enum extension_type { NO, LIST_EXTENSIONS, CAPABILITIES };
+	enum extension_type { NO, LIST_EXTENSIONS, CAPABILITIES, BROKEN };
 	/* Set so we don't reconnect just to QUIT */
 	static t_bool quitting = FALSE;
 #endif /* NNTP_ABLE */
@@ -895,6 +893,15 @@
 		 * when user is quitting tin if tinrc.auto_reconnect is false.
 		 */
 		if (strncmp(last_put, "QUIT", 4)) {
+			/*
+			 * Typhoon v2.1.1.363 colses the connection right after an unknown
+			 * command, (i.e. CAPABILITIES) so we avoid the reissue it on a
+			 * reconnect if it was the last command.
+			 */
+			if (!strncmp(last_put, "CAPABILITIES", 12)) {
+				strcpy(last_put, "MODE READER");
+				nntp_caps.type = BROKEN;
+			}
 			retry = reconnect(retry);		/* Will abort when out of tries */
 			reconnected_in_last_get_server = TRUE;
 		} else {
@@ -1045,6 +1052,14 @@
 								nntp_caps.over_msgid = TRUE;
 							d = strpbrk(d, " \t");
 						}
+					}
+					/*
+					 * NOTE: if we saw HDR, LIST HEADERS _must_ be implemented
+					 */
+					else if (!strcasecmp(ptr, &xhdr_cmds[1])) {
+						nntp_caps.hdr_cmd = &xhdr_cmds[1];
+						nntp_caps.hdr = TRUE;
+						nntp_caps.list_headers = TRUE;
 					} else if (!strcasecmp(ptr, "AUTHINFO")) {
 						d = ptr + 8;
 						d = strpbrk(d, " \t");
@@ -1058,20 +1073,12 @@
 						}
 					}
 #		if 0
-					/*
-					 * NOTE: if we saw HDR, LIST HEADERS _must_ be implemented
-					 */
-					else if (!strcasecmp(ptr, &xhdr_cmds[1])) {
-						nntp_caps.hdr_cmd = &xhdr_cmds[1];
-						nntp_caps.hdr = TRUE;
-						nntp_caps.list_headers = TRUE;
-					}
 					else if (!strcasecmp(ptr, "IHAVE"))
 						nntp_caps.ihave = TRUE;
-#		endif /* 0 */
 					/*
 					 * TODO: SASL, STREAMING
 					 */
+#		endif /* 0 */
 				} else
 					nntp_caps.type = NO;
 			}
@@ -1346,8 +1353,15 @@
 	 *       extensions. (For details about authentication methods, see
 	 *       draft-ietf-nntpext-authinfo-07.txt).
 	 */
-	if ((ret = check_extensions(&sec)))
-		return ret; /* required "MODE READER" failed, exit */
+	if (nntp_caps.type != BROKEN) {
+	/*
+	 * Typhoon v2.1.1.363 closes the connection after an unknown command
+	 * (i.e. CAPABILITIES) but as we are not allowed to cache CAPABILITIES
+	 * we reissue the command on reconnect ... loop 
+	 */
+		if ((ret = check_extensions(&sec)))
+			return ret; /* required "MODE READER" failed, exit */
+	}
 
 	/*
 	 * If the user wants us to authenticate on connection startup, do it now.
@@ -1462,16 +1476,14 @@
 					break;
 			}
 		}
-#	if 0 /* unused */
 		if (!nntp_caps.hdr_cmd) {
 			/*
-			 * LIST EXTENSIONS didn't mention HDR or XHDR, try
+			 * CAPABILITIES/LIST EXTENSIONS didn't mention HDR or XHDR, try
 			 * XHDR
 			 */
 			if (!nntp_command(xhdr_cmds, ERR_COMMAND, NULL, 0))
 				nntp_caps.hdr_cmd = xhdr_cmds;
 		}
-#	endif /* 0 */
 	}
 
 	if (!nntp_caps.over_cmd) {
@@ -1483,16 +1495,15 @@
 			else
 				wait_message(2, _(txt_caching_off));
 		}
+	}
 #	if 0
-	} else {
+	else {
 		/*
 		 * TODO: issue warning if old index files found?
 		 *	      in index_newsdir?
 		 */
-#	endif /* 0 */
 	}
 
-#	if 0
 	/*
 	 * TODO: if we're using -n, check for LIST NEWSGROUPS <wildmat>
 	 * see also comments in open_newsgroups_fp()




